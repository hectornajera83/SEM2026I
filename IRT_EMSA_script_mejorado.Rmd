---
title: "Ejercicio: IRT. SEM y medici√≥n economico-social"
author: "H√©ctor N√°jera"
date: "14/11/2024"
output: html_document
---

```{r message=FALSE}
#install.packages("latticeExtra")
#install.packages("pracma")
#install.packages("gridExtra")
library(latticeExtra)
library(mirt)
library(ggplot2)
library(gridExtra)
library(pracma)
```

La EMSA descansa en dos supuestos fundamentales:

1. La EMSA es unidimensional, i.e. los indicadores son manifestaciones de un mismo constructo.
2. Los indicadores miden distintos niveles de severidad de seguridad alimentaria y discriminan equivalentemente (i.e. se trata de un modelo RASCH)
3. La suma simple de los indicadores puede usarse para clasificar a la poblaci√≥n en 4 grupos.

**¬øQu√© significan estos supuestos?**

## Datos

El archivo `"DatosEMSA2008.csv"` contiene los datos (15 columnas). La primera columna es el id de la persona y las siguientes 12 columnas corresponden a los indicadores binarios de la EMSA (1=Carencia; 0=Sin Carencia), la columna 14 es el identificador de pobreza por ingreso y la columna 15 contiene el total de integrantes del hogar.


```{r message=FALSE, include=TRUE, tidy=TRUE}
D<-read.csv("DatosEMSA2008.csv")
head(D)
```

```{r fig.cap="Items de la EMSA",  out.height = "900px", out.width = "1300px", echo=FALSE}
knitr::include_graphics("EMSA.png")
```

Primero estimamos la prevalencias de cada episodio de hambre o de poca variedad de alimentos. Observamos cierta relaci√≥n entre la crudeza del episodio de hambre y la proporci√≥n de hogares con la carencia. Ha mayor crudeza menor prevalencia. Esto es lo que esperar√≠amos observar en una escala que busca capturar distintas severidades del fen√≥meno de inter√©s. 

```{r include=TRUE}
colMeans(D[,2:13])*100
```

Exceso de zeros:

```{r}
library(tidyverse)

D_subset <- D[, 2:13]
D_long <- D_subset %>% 
  pivot_longer(cols = everything(),
               names_to   = "variable",
               values_to  = "value")
counts <- D_long %>%
  group_by(variable, value) %>%
  summarise(n = n(), .groups = "drop")
scalogram <- ggplot(counts, aes(x = variable,
                                y = n,
                                fill = factor(value))) +
  geom_col(show.legend = FALSE) +
  scale_fill_manual(values = c("0" = "#1f77b4",
                               "1" = "#ff7f0e")) +
  labs(#title   = "Excess of Zeroes in Binary Variables (Columns 2‚Äì13)",
       y      = "Count",
       x      = NULL,
       caption = "Blue = sin carencia, Orange = con carencia") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(scalogram)

```



## Teor√≠a de respuesta al √≠tem

Nos hemos enfocado en la confiabilidad global de los scores. Sin emabrgo, no tenemos mucha idea del tipo de informaci√≥n que aporta cada √≠tem a los scores globales. Esto es importante porque la EMSA apunta a capturar distintas severidades del fen√≥menos de inter√©s. Estimaremos primero un modelo **Rasch** puesto que es el modelo te√≥rico que deber√≠a representarse en los datos. Este modelo supone que las diferencias de los √≠tems ocurren en t√©rminos de severidad y no de discriminaci√≥n. Usaremos el paquete `mirt()` y la opci√≥n `rasch()`. 

```{r include=TRUE}
library(mirt)

m<-mirt(D[,2:13], 1, itemtype = 'Rasch')
```

Ahora inspeccionamos los par√°metros con la funci√≥n `coef`. Donde a es la discriminaci√≥n y b es la severidad. g es el par√°metro de la suerte. 

```{r message=FALSE}
coef(m, IRTpars = T, simplify = T)
```

Los √≠tems de la EMSA parecen capturar distintos grados de severidad. Observamos que los √≠tems de adultos tienenden a ser menos severos (a la izquierda) que los de infancia. Parece razonable el supuesto de la EMSA. Sin embargo, las distancia entre varias de las curvas son peque√±as y algunas se traslpan. Esto significa que algunos de los indicadores son redundantes.

```{r message=FALSE}
plot(m, type = "trace")
```

Si queremos ver todos los indicadores

```{r message=FALSE}
plot(m, type = 'trace', auto.key = FALSE, which.items = 1:12, facet_items=FALSE)
```

### Mejores gr√°ficas con `ggplot2`

```{r message=FALSE}
plt <- plot(m, type = 'trace', facet_items=FALSE) #store the object
#print(plt) #plot the object
#str(plt) #find the data
#plt$panel.args
pltdata <- data.frame(lapply(plt$panel.args, function(x) do.call(cbind, x))[[1]])
pltdata$item <- rep(colnames(D[,2:13]), each = 200)
head(pltdata)

library(ggplot2)
ggplot(pltdata, aes(x, y, colour=item)) + geom_line() + ggtitle('ggplot2 Tracelines') +
    xlab(expression(theta)) + ylab(expression(P(theta))) + theme_classic() + xlim(c(-3,3))
```


## Modelo de dos par√°metros

Ahora estimamos un modelo de teor√≠a de respuesta al √≠tem de dos par√°metros. Cambiamos el argumento `itemtype="2PL"`. 

Es decir, relajamos el supuesto de que la dificultad es la misma para todos los √≠tems. Observamos que el supuesto del modelo rasch no parece sostenerse. Las pendientes tienenden a ser distintas y las curvas de alguos √≠tem cruzan otras curvas. Ciertos √≠tems como el *iaa_4* parecen tocar distintos niveles de seguridad alimentaria. Aunque los par√°metros de discriminaci√≥n son distintos, en todos los casos son valores altos $\geq.9$. Esto es consistente con los altos valores de las $\lambda$'s del modelo factorial. 

```{r message=FALSE}
m2<-mirt(D[,2:13], 1, itemtype = '2PL')
coef(m2, IRTpars = T, simplify = T)
```

```{r message=FALSE}
plot(m2, type = 'trace', auto.key = FALSE, which.items = 1:12, facet_items=FALSE)
```

### Mejores gr√°ficas con ggplot2

```{r message=FALSE}
plt <- plot(m2, type = 'trace', facet_items=FALSE) #store the object
#print(plt) #plot the object
#str(plt) #find the data
#plt$panel.args
pltdata <- data.frame(lapply(plt$panel.args, function(x) do.call(cbind, x))[[1]])
pltdata$item <- rep(colnames(D[,2:13]), each = 200)
head(pltdata)

library(ggplot2)
ggplot(pltdata, aes(x, y, colour=item)) + geom_line() + ggtitle('ICC') +
    xlab(expression(theta)) + ylab(expression(P(theta))) + xlim(c(-3,3))
```

```{r}
plot(m2, type = 'trace', auto.key = FALSE, which.items = 4:8, facet_items=FALSE)
```

## Curva total de informaci√≥n

La informaci√≥n puede partirse en distintos segmentos. Por ejemplo, si quisieramos saber la informaci√≥n para un nivel de severidad dado entre -2 y 0 desviaciones est√°ndar podemos utilizar la funci√≥n `areainfo()`. 

```{r}
areainfo(m2, c(-2,0), which.items = 1:12)
```
Una forma de graficar los resultados para la mayor√≠a de la distribuci√≥n de la variable latente es extrayendo la informaci√≥n para distintos niveles de Theta. Una vez hecho esto, es posible graficar la curva total de informaci√≥n. 

```{r}
Theta <- matrix(seq(-3,3, length.out=1000))
info <- testinfo(m2, Theta)
plot(info ~ Theta, type = 'l')
```

```{r}
plot(m2, type = 'infoSE', theta_lim = c(-3,3))
```


## Comparaci√≥n de modelos

Podemos utilizar la funci√≥n `anova()` para comparar los estad√≠sticos de ajuste de ambos modelos. Dado que AICc y BIC son menores para el segundo modelo, concluimos que el segundo modelo es MEJOR! 

```{r}
anova(m, m2)
```


## Test scores

# Test scores y escalamiento en TRI

Dado un modelo, se estima el score estimado

```{r}
Theta <- matrix(seq(-3,3,.01))
tscore <- expected.test(m2, Theta)
```

## Graficamos la relaci√≥n de cada score con Theta

```{r}
plot(cbind(Theta, tscore))
```

# =============================================================
# NUEVAS SECCIONES: An√°lisis Avanzados de la Relaci√≥n Score-Theta
# =============================================================

## An√°lisis 1: Relaci√≥n entre Score Observado y Theta Estimado - Comparaci√≥n Rasch vs 2PL

Una pregunta fundamental en IRT es: ¬øc√≥mo se relaciona el score observado (suma simple de √≠tems) con la habilidad latente estimada (theta)? Esta relaci√≥n NO es lineal, y **difiere entre modelos**. Vamos a comparar c√≥mo el modelo Rasch (1 par√°metro) y el modelo 2PL (2 par√°metros) estiman theta para los mismos scores observados.

```{r message=FALSE, warning=FALSE}
# Funci√≥n mejorada para comparar modelos
comparar_modelos_score_theta <- function(modelo_rasch, modelo_2pl, datos) {
  # Calcular scores observados (suma simple)
  scores_observados <- rowSums(datos)
  
  # Estimar theta para modelo RASCH
  theta_rasch_matrix <- fscores(modelo_rasch, method = "EAP", full.scores = TRUE)
  if(is.matrix(theta_rasch_matrix)) {
    theta_rasch <- theta_rasch_matrix[,1]
    se_rasch <- if(ncol(theta_rasch_matrix) > 1) theta_rasch_matrix[,2] else rep(0.3, nrow(theta_rasch_matrix))
  } else {
    theta_rasch <- as.vector(theta_rasch_matrix)
    se_rasch <- rep(0.3, length(theta_rasch))
  }
  
  # Estimar theta para modelo 2PL
  theta_2pl_matrix <- fscores(modelo_2pl, method = "EAP", full.scores = TRUE)
  if(is.matrix(theta_2pl_matrix)) {
    theta_2pl <- theta_2pl_matrix[,1]
    se_2pl <- if(ncol(theta_2pl_matrix) > 1) theta_2pl_matrix[,2] else rep(0.3, nrow(theta_2pl_matrix))
  } else {
    theta_2pl <- as.vector(theta_2pl_matrix)
    se_2pl <- rep(0.3, length(theta_2pl))
  }
  
  # Crear dataframe comparativo
  df_comparacion <- data.frame(
    score = scores_observados,
    theta_rasch = theta_rasch,
    theta_2pl = theta_2pl,
    se_rasch = se_rasch,
    se_2pl = se_2pl,
    diferencia = theta_2pl - theta_rasch
  )
  
  # Gr√°fico 1: Comparaci√≥n directa de thetas
  p1 <- ggplot(df_comparacion) +
    geom_point(aes(x = score, y = theta_rasch, color = "Rasch"), 
               alpha = 0.3, position = position_jitter(width = 0.05)) +
    geom_point(aes(x = score, y = theta_2pl, color = "2PL"), 
               alpha = 0.3, position = position_jitter(width = 0.05)) +
    geom_smooth(aes(x = score, y = theta_rasch, color = "Rasch"), 
                method = "loess", se = FALSE, size = 1.2) +
    geom_smooth(aes(x = score, y = theta_2pl, color = "2PL"), 
                method = "loess", se = FALSE, size = 1.2) +
    scale_color_manual(values = c("Rasch" = "blue", "2PL" = "red")) +
    labs(title = "Comparaci√≥n: \n Score Observado vs Theta Estimado",
         subtitle = "Modelo Rasch (azul) vs Modelo 2PL (rojo)",
         x = "Score Observado (suma de √≠tems)",
         y = expression(theta ~ "(habilidad latente)"),
         color = "Modelo") +
    theme_minimal() +
    scale_x_continuous(breaks = 0:12)
  
  # Gr√°fico 2: Diferencia entre modelos
  p2 <- ggplot(df_comparacion, aes(x = score, y = diferencia)) +
    geom_boxplot(aes(group = score), fill = "lightgreen", alpha = 0.7) +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    geom_smooth(method = "loess", color = "darkgreen", se = TRUE) +
    labs(title = "Diferencia en Estimaci√≥n de Theta \n entre Modelos",
         subtitle = "Theta(2PL) - Theta(Rasch)",
         x = "Score Observado",
         y = "Diferencia en Theta") +
    theme_minimal() +
    scale_x_continuous(breaks = 0:12)
  
  # Tabla comparativa por score
  tabla_comparacion <- aggregate(cbind(theta_rasch, theta_2pl, diferencia) ~ score, 
                                 df_comparacion, 
                                 function(x) c(mean = round(mean(x), 3), 
                                             sd = round(sd(x), 3)))
  tabla_comparacion <- do.call(data.frame, tabla_comparacion)
  colnames(tabla_comparacion) <- c("Score", "Theta_Rasch_Mean", "Theta_Rasch_SD",
                                   "Theta_2PL_Mean", "Theta_2PL_SD",
                                   "Diferencia_Mean", "Diferencia_SD")
  
  # Gr√°fico 3: Correlaci√≥n entre estimaciones
  correlacion <- cor(df_comparacion$theta_rasch, df_comparacion$theta_2pl)
  
  p3 <- ggplot(df_comparacion, aes(x = theta_rasch, y = theta_2pl)) +
    geom_point(alpha = 0.3) +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    geom_smooth(method = "lm", se = TRUE, color = "blue") +
    annotate("text", x = -2, y = 2, 
             label = paste("r =", round(correlacion, 3)), 
             size = 4, color = "blue") +
    labs(title = "Correlaci√≥n entre Estimaciones Rasch vs 2PL",
         subtitle = "L√≠nea roja = Concordancia perfecta",
         x = expression(theta ~ "Rasch"),
         y = expression(theta ~ "2PL")) +
    theme_minimal() +
    coord_fixed()
  
  # Mostrar gr√°ficos
  grid.arrange(p1, p2, ncol = 2)
  print(p3)
  
  return(list(
    datos = df_comparacion,
    tabla = tabla_comparacion,
    correlacion = correlacion,
    graficos = list(comparacion = p1, diferencia = p2, correlacion = p3)
  ))
}

# Aplicar la comparaci√≥n
cat("\n=== COMPARACI√ìN MODELOS: RASCH vs 2PL ===\n")
comparacion_modelos <- comparar_modelos_score_theta(m, m2, D[,2:13])

cat("\nTabla comparativa por score:\n")
print(comparacion_modelos$tabla)

cat("\n\nCorrelaci√≥n entre estimaciones Rasch y 2PL:", round(comparacion_modelos$correlacion, 3), "\n")

# An√°lisis adicional: ¬øD√≥nde difieren m√°s los modelos?
cat("\n=== AN√ÅLISIS DE DIFERENCIAS ===\n")
cat("Scores donde los modelos difieren m√°s (|diferencia| > 0.1):\n")
dif_relevantes <- comparacion_modelos$tabla[abs(comparacion_modelos$tabla$Diferencia_Mean) > 0.1,]
if(nrow(dif_relevantes) > 0) {
  print(dif_relevantes[,c("Score", "Theta_Rasch_Mean", "Theta_2PL_Mean", "Diferencia_Mean")])
} else {
  cat("No hay diferencias sustanciales > 0.1 entre modelos\n")
}
```

### Interpretaci√≥n de la comparaci√≥n Rasch vs 2PL:

**Diferencias clave entre modelos:**
- **Modelo Rasch**: Asume que todos los √≠tems discriminan igualmente (a = constante), solo difieren en dificultad (b)
- **Modelo 2PL**: Permite que cada √≠tem tenga su propia discriminaci√≥n (a) y dificultad (b)

**Observaciones de la comparaci√≥n:**
1. **Alta correlaci√≥n**: Ambos modelos producen estimaciones similares pero no id√©nticas
2. **Diferencias en extremos**: Las mayores diferencias suelen ocurrir en scores muy bajos o muy altos
3. **Compresi√≥n diferencial**: El modelo 2PL puede producir mayor dispersi√≥n en theta debido a las diferentes discriminaciones
4. **Implicaciones pr√°cticas**: 
   - Si los modelos difieren mucho ‚Üí Los √≠tems tienen discriminaciones muy diferentes
   - Si los modelos son similares ‚Üí El supuesto Rasch es razonable

## An√°lisis 2: Informaci√≥n Aportada por cada Nivel de Score - Comparaci√≥n de Modelos

No todos los scores aportan la misma cantidad de informaci√≥n. Adem√°s, la informaci√≥n puede diferir entre modelos Rasch y 2PL.

```{r message=FALSE, warning=FALSE}
# Funci√≥n mejorada para comparar informaci√≥n entre modelos
comparar_informacion_modelos <- function(modelo_rasch, modelo_2pl, datos) {
  # Calcular scores observados
  scores_observados <- rowSums(datos)
  
  # Estimar theta para cada persona - Modelo RASCH
  theta_rasch_matrix <- fscores(modelo_rasch, method = "EAP", full.scores = TRUE)
  if(is.matrix(theta_rasch_matrix)) {
    theta_rasch <- theta_rasch_matrix[,1]
  } else {
    theta_rasch <- as.vector(theta_rasch_matrix)
  }
  
  # Estimar theta para cada persona - Modelo 2PL
  theta_2pl_matrix <- fscores(modelo_2pl, method = "EAP", full.scores = TRUE)
  if(is.matrix(theta_2pl_matrix)) {
    theta_2pl <- theta_2pl_matrix[,1]
  } else {
    theta_2pl <- as.vector(theta_2pl_matrix)
  }
  
  # Calcular informaci√≥n para cada persona en ambos modelos
  info_rasch <- numeric(length(theta_rasch))
  info_2pl <- numeric(length(theta_2pl))
  
  for(i in 1:length(theta_rasch)) {
    info_rasch[i] <- testinfo(modelo_rasch, matrix(theta_rasch[i]))
    info_2pl[i] <- testinfo(modelo_2pl, matrix(theta_2pl[i]))
  }
  
  # Crear dataframe comparativo
  df_info <- data.frame(
    score = scores_observados,
    theta_rasch = theta_rasch,
    theta_2pl = theta_2pl,
    info_rasch = info_rasch,
    info_2pl = info_2pl,
    se_rasch = 1/sqrt(info_rasch),
    se_2pl = 1/sqrt(info_2pl)
  )
  
  # Visualizaci√≥n comparativa
  p1 <- ggplot(df_info) +
    geom_boxplot(aes(x = score, y = info_rasch, group = score), 
                 fill = "lightblue", alpha = 0.5) +
    geom_boxplot(aes(x = score, y = info_2pl, group = score), 
                 fill = "lightcoral", alpha = 0.5) +
    geom_smooth(aes(x = score, y = info_rasch), 
                method = "loess", color = "blue", se = FALSE, size = 1.2) +
    geom_smooth(aes(x = score, y = info_2pl), 
                method = "loess", color = "red", se = FALSE, size = 1.2) +
    labs(title = "Comparaci√≥n de Informaci√≥n: \n Rasch (azul) vs 2PL (rojo)",
         x = "Score Observado",
         y = "Informaci√≥n del Test") +
    theme_minimal() +
    scale_x_continuous(breaks = 0:12)
  
  p2 <- ggplot(df_info) +
    geom_boxplot(aes(x = score, y = se_rasch, group = score), 
                 fill = "lightblue", alpha = 0.5) +
    geom_boxplot(aes(x = score, y = se_2pl, group = score), 
                 fill = "lightcoral", alpha = 0.5) +
    geom_smooth(aes(x = score, y = se_rasch), 
                method = "loess", color = "blue", se = FALSE, size = 1.2) +
    geom_smooth(aes(x = score, y = se_2pl), 
                method = "loess", color = "red", se = FALSE, size = 1.2) +
    labs(title = "Comparaci√≥n de Error Est√°ndar: \n Rasch (azul) vs 2PL (rojo)",
         x = "Score Observado",
         y = "Error Est√°ndar de Medici√≥n") +
    theme_minimal() +
    scale_x_continuous(breaks = 0:12)
  
  # Resumen comparativo
  df_resumen <- aggregate(cbind(info_rasch, info_2pl, se_rasch, se_2pl) ~ score, 
                          df_info, 
                          function(x) round(mean(x), 3))
  
  # Calcular diferencia porcentual en informaci√≥n
  df_resumen$ganancia_info <- round((df_resumen$info_2pl - df_resumen$info_rasch) / 
                                    df_resumen$info_rasch * 100, 1)
  
  grid.arrange(p1, p2, ncol = 2)
  
  return(list(
    datos = df_info, 
    resumen = df_resumen,
    graficos = list(informacion = p1, error = p2)
  ))
}

# Aplicar comparaci√≥n
cat("\n=== COMPARACI√ìN DE INFORMACI√ìN: RASCH vs 2PL ===\n")
info_comparacion <- comparar_informacion_modelos(m, m2, D[,2:13])

cat("\nResumen por score (medias):\n")
print(info_comparacion$resumen[,c("score", "info_rasch", "info_2pl", "ganancia_info")])

cat("\n\nGanancia promedio de informaci√≥n del 2PL sobre Rasch:", 
    round(mean(info_comparacion$resumen$ganancia_info, na.rm = TRUE), 1), "%\n")
```

### Interpretaci√≥n de la comparaci√≥n de informaci√≥n:
- **Modelo 2PL generalmente m√°s informativo**: Al permitir diferentes discriminaciones, suele aportar m√°s informaci√≥n
- **Ganancia variable**: La mejora del 2PL sobre Rasch no es uniforme en todos los scores
- **Trade-off**: Mayor complejidad del 2PL vs parsimonia del Rasch
- **Implicaci√≥n pr√°ctica**: Si la ganancia es m√≠nima, el modelo Rasch puede ser preferible por su simplicidad

## An√°lisis 3: Puntos de Corte - Comparaci√≥n con Particiones Tradicionales EMSA

Un aspecto crucial es comparar los puntos de corte tradicionales del modelo Rasch (0, 1-3, 4-7, 8-12) con lo que sugiere la funci√≥n de informaci√≥n del test.

```{r message=FALSE, warning=FALSE}
# Funci√≥n para analizar y comparar puntos de corte tradicionales vs √≥ptimos
comparar_puntos_corte_tradicionales <- function(modelo_rasch, modelo_2pl, datos) {
  # PARTICIONES TRADICIONALES EMSA (basadas en conteo simple)
  particiones_tradicionales <- list(
    "Seguridad Alimentaria" = 0,
    "Inseguridad Leve" = 1:3,
    "Inseguridad Moderada" = 4:7,
    "Inseguridad Severa" = 8:12
  )
  
  # Calcular scores observados
  scores_obs <- rowSums(datos)
  
  # Estimar theta para ambos modelos
  theta_rasch_matrix <- fscores(modelo_rasch, method = "EAP", full.scores = TRUE)
  theta_2pl_matrix <- fscores(modelo_2pl, method = "EAP", full.scores = TRUE)
  
  theta_rasch <- if(is.matrix(theta_rasch_matrix)) theta_rasch_matrix[,1] else as.vector(theta_rasch_matrix)
  theta_2pl <- if(is.matrix(theta_2pl_matrix)) theta_2pl_matrix[,1] else as.vector(theta_2pl_matrix)
  
  # AN√ÅLISIS 1: Theta promedio por categor√≠a tradicional
  cat("\n=== THETA PROMEDIO POR CATEGOR√çA TRADICIONAL ===\n")
  
  theta_por_categoria <- data.frame()
  for(cat_name in names(particiones_tradicionales)) {
    scores_cat <- particiones_tradicionales[[cat_name]]
    idx_cat <- which(scores_obs %in% scores_cat)
    
    if(length(idx_cat) > 0) {
      theta_por_categoria <- rbind(theta_por_categoria,
        data.frame(
          Categoria = cat_name,
          Scores = paste(min(scores_cat), "-", max(scores_cat)),
          N = length(idx_cat),
          Theta_Rasch_Mean = round(mean(theta_rasch[idx_cat]), 3),
          Theta_Rasch_SD = round(sd(theta_rasch[idx_cat]), 3),
          Theta_2PL_Mean = round(mean(theta_2pl[idx_cat]), 3),
          Theta_2PL_SD = round(sd(theta_2pl[idx_cat]), 3)
        )
      )
    }
  }
  
  # Ajustar la columna Scores para score √∫nico
  theta_por_categoria$Scores[1] <- "0"
  
  print(theta_por_categoria)
  
  # AN√ÅLISIS 2: Informaci√≥n del test en puntos de transici√≥n
  cat("\n\n=== INFORMACI√ìN EN PUNTOS DE TRANSICI√ìN ===\n")
  
  # Puntos de transici√≥n entre categor√≠as (scores: 0‚Üí1, 3‚Üí4, 7‚Üí8)
  transiciones <- c(0.5, 3.5, 7.5)  # Entre scores
  
  # Calcular theta correspondiente a cada punto de transici√≥n
  theta_transiciones <- numeric(length(transiciones))
  info_transiciones_rasch <- numeric(length(transiciones))
  info_transiciones_2pl <- numeric(length(transiciones))
  
  for(i in 1:length(transiciones)) {
    # Interpolaci√≥n de theta en el punto de transici√≥n
    score_bajo <- floor(transiciones[i])
    score_alto <- ceiling(transiciones[i])
    
    idx_bajo <- which(scores_obs == score_bajo)
    idx_alto <- which(scores_obs == score_alto)
    
    if(length(idx_bajo) > 0 && length(idx_alto) > 0) {
      theta_bajo_rasch <- mean(theta_rasch[idx_bajo])
      theta_alto_rasch <- mean(theta_rasch[idx_alto])
      theta_transiciones[i] <- (theta_bajo_rasch + theta_alto_rasch) / 2
      
      # Calcular informaci√≥n en ese punto
      info_transiciones_rasch[i] <- testinfo(modelo_rasch, matrix(theta_transiciones[i]))
      info_transiciones_2pl[i] <- testinfo(modelo_2pl, matrix(theta_transiciones[i]))
    }
  }
  
  df_transiciones <- data.frame(
    Transicion = c("Seguridad‚ÜíLeve (0‚Üí1)", 
                   "Leve‚ÜíModerada (3‚Üí4)", 
                   "Moderada‚ÜíSevera (7‚Üí8)"),
    Theta_Transicion = round(theta_transiciones, 3),
    Info_Rasch = round(info_transiciones_rasch, 2),
    Info_2PL = round(info_transiciones_2pl, 2),
    SE_Rasch = round(1/sqrt(info_transiciones_rasch), 3),
    SE_2PL = round(1/sqrt(info_transiciones_2pl), 3)
  )
  
  print(df_transiciones)
  
  # AN√ÅLISIS 3: Clasificaci√≥n √≥ptima basada en informaci√≥n
  cat("\n\n=== PUNTOS DE CORTE √ìPTIMOS BASADOS EN INFORMACI√ìN ===\n")
  
  # Buscar m√≠nimos locales en la funci√≥n de informaci√≥n (valles)
  theta_rango <- seq(-3, 3, by = 0.05)
  info_rasch_continuo <- testinfo(modelo_rasch, matrix(theta_rango))
  info_2pl_continuo <- testinfo(modelo_2pl, matrix(theta_rango))
  
  # Encontrar m√≠nimos locales (valles) en la informaci√≥n - buenos puntos de corte
  library(pracma)
  
  # Invertir para encontrar m√≠nimos como m√°ximos
  valles_rasch <- findpeaks(-info_rasch_continuo, npeaks = 3)
  valles_2pl <- findpeaks(-info_2pl_continuo, npeaks = 3)
  
  if(!is.null(valles_rasch)) {
    cortes_info_rasch <- sort(theta_rango[valles_rasch[,2]])
  } else {
    # Si no encuentra valles, usar cuartiles
    cortes_info_rasch <- quantile(theta_rasch, probs = c(0.25, 0.5, 0.75))
  }
  
  if(!is.null(valles_2pl)) {
    cortes_info_2pl <- sort(theta_rango[valles_2pl[,2]])
  } else {
    cortes_info_2pl <- quantile(theta_2pl, probs = c(0.25, 0.5, 0.75))
  }
  
  # AN√ÅLISIS 4: Comparaci√≥n visual
  
  # Crear dataframe para visualizaci√≥n
  df_viz <- data.frame(
    score = scores_obs,
    theta_rasch = theta_rasch,
    theta_2pl = theta_2pl,
    categoria_tradicional = NA
  )
  
  # Asignar categor√≠as tradicionales
  for(i in 1:nrow(df_viz)) {
    if(df_viz$score[i] == 0) df_viz$categoria_tradicional[i] <- "Seguridad"
    else if(df_viz$score[i] <= 3) df_viz$categoria_tradicional[i] <- "Leve"
    else if(df_viz$score[i] <= 7) df_viz$categoria_tradicional[i] <- "Moderada"
    else df_viz$categoria_tradicional[i] <- "Severa"
  }
  
  df_viz$categoria_tradicional <- factor(df_viz$categoria_tradicional, 
                                         levels = c("Seguridad", "Leve", "Moderada", "Severa"))
  
  # Gr√°fico 1: Distribuci√≥n de theta por categor√≠a tradicional
  p1 <- ggplot(df_viz, aes(x = categoria_tradicional, y = theta_2pl)) +
    geom_boxplot(aes(fill = categoria_tradicional), alpha = 0.7) +
    geom_violin(aes(fill = categoria_tradicional), alpha = 0.3) +
    scale_fill_manual(values = c("Seguridad" = "green", "Leve" = "yellow", 
                                 "Moderada" = "orange", "Severa" = "red")) +
    labs(title = "Distribuci√≥n de Theta (2PL) \n por Categor√≠a Tradicional",
         subtitle = "Particiones: 0 | 1-3 | 4-7 | 8-12",
         x = "Categor√≠a Tradicional",
         y = expression(theta ~ "(2PL)")) +
    theme_minimal() +
    theme(legend.position = "none")
  
  # Calcular informaci√≥n promedio por score
  info_por_score <- data.frame(score = 0:12)
  for(s in 0:12) {
    idx_score <- which(scores_obs == s)
    if(length(idx_score) > 0) {
      theta_medio <- mean(theta_2pl[idx_score])
      info_por_score$info_2pl[s+1] <- testinfo(modelo_2pl, matrix(theta_medio))
      info_por_score$info_rasch[s+1] <- testinfo(modelo_rasch, matrix(theta_medio))
      info_por_score$n[s+1] <- length(idx_score)
    } else {
      info_por_score$info_2pl[s+1] <- NA
      info_por_score$info_rasch[s+1] <- NA
      info_por_score$n[s+1] <- 0
    }
  }
  
  # Gr√°fico 2: Informaci√≥n por score con l√≠neas de corte tradicionales
  p2 <- ggplot(info_por_score, aes(x = score)) +
    geom_line(aes(y = info_2pl, color = "2PL"), size = 1.2, na.rm = TRUE) +
    geom_line(aes(y = info_rasch, color = "Rasch"), size = 1.2, linetype = "dashed", na.rm = TRUE) +
    geom_point(aes(y = info_2pl), color = "red", size = 2, na.rm = TRUE) +
    geom_point(aes(y = info_rasch), color = "blue", size = 2, na.rm = TRUE) +
    
    # A√±adir l√≠neas verticales en los puntos de corte tradicionales
    geom_vline(xintercept = c(0.5, 3.5, 7.5), 
               color = "darkgreen", linetype = "dotted", size = 1, alpha = 0.7) +
    
    # √Åreas sombreadas por categor√≠a
    annotate("rect", xmin = -0.5, xmax = 0.5, ymin = 0, ymax = Inf, 
             fill = "green", alpha = 0.1) +
    annotate("rect", xmin = 0.5, xmax = 3.5, ymin = 0, ymax = Inf, 
             fill = "yellow", alpha = 0.1) +
    annotate("rect", xmin = 3.5, xmax = 7.5, ymin = 0, ymax = Inf, 
             fill = "orange", alpha = 0.1) +
    annotate("rect", xmin = 7.5, xmax = 12.5, ymin = 0, ymax = Inf, 
             fill = "red", alpha = 0.1) +
    
    scale_color_manual(values = c("2PL" = "red", "Rasch" = "blue")) +
    labs(title = "Informaci√≥n del Test por Score \n con Particiones Tradicionales",
         subtitle = "L√≠neas punteadas = puntos de corte (0|1-3|4-7|8-12)",
         x = "Score Observado",
         y = "Informaci√≥n",
         color = "Modelo") +
    theme_minimal() +
    scale_x_continuous(breaks = 0:12)
  
  # Gr√°fico 3: Curva de informaci√≥n continua con todos los puntos de corte
  df_info_continuo <- data.frame(
    theta = theta_rango,
    info_rasch = info_rasch_continuo,
    info_2pl = info_2pl_continuo
  )
  
  # Calcular theta correspondiente a scores de corte tradicionales
  theta_cortes_trad <- numeric(3)
  for(i in 1:3) {
    theta_cortes_trad[i] <- theta_transiciones[i]
  }
  
  p3 <- ggplot(df_info_continuo, aes(x = theta)) +
    geom_line(aes(y = info_2pl), color = "red", size = 1.2) +
    geom_line(aes(y = info_rasch), color = "blue", size = 1.2, linetype = "dashed") +
    
    # Puntos de corte tradicionales (en theta)
    geom_vline(xintercept = theta_cortes_trad, 
               color = "darkgreen", linetype = "dotted", size = 1) +
    
    # Puntos de corte √≥ptimos basados en informaci√≥n
    if(length(cortes_info_2pl) >= 3) {
      geom_vline(xintercept = cortes_info_2pl[1:3], 
                 color = "purple", linetype = "dashed", size = 1, alpha = 0.7)
    }
    
    labs(title = "Funci√≥n de Informaci√≥n: Cortes Tradicionales vs √ìptimos",
         subtitle = "Verde (..) = Tradicionales | P√∫rpura (--) = √ìptimos por informaci√≥n",
         x = expression(theta),
         y = "Informaci√≥n") +
    theme_minimal() +
    
    # A√±adir etiquetas
    annotate("text", x = -2, y = max(info_2pl_continuo)*0.9, 
             label = "Seguridad", size = 3, color = "darkgreen") +
    annotate("text", x = -0.5, y = max(info_2pl_continuo)*0.9, 
             label = "Leve", size = 3, color = "darkgreen") +
    annotate("text", x = 0.5, y = max(info_2pl_continuo)*0.9, 
             label = "Moderada", size = 3, color = "darkgreen") +
    annotate("text", x = 2, y = max(info_2pl_continuo)*0.9, 
             label = "Severa", size = 3, color = "darkgreen")
  
  # Mostrar gr√°ficos
  library(gridExtra)
  grid.arrange(p1, p2, ncol = 2)
  print(p3)
  
  # AN√ÅLISIS 5: Evaluaci√≥n de la calidad de las particiones
  cat("\n\n=== EVALUACI√ìN DE LAS PARTICIONES TRADICIONALES ===\n")
  
  # Calcular traslape entre categor√≠as adyacentes
  traslape <- data.frame()
  
  categorias <- c("Seguridad", "Leve", "Moderada", "Severa")
  for(i in 1:(length(categorias)-1)) {
    cat1 <- categorias[i]
    cat2 <- categorias[i+1]
    
    theta1 <- df_viz$theta_2pl[df_viz$categoria_tradicional == cat1]
    theta2 <- df_viz$theta_2pl[df_viz$categoria_tradicional == cat2]
    
    # Calcular traslape (proporci√≥n de casos mal clasificados si usamos la media como punto de corte)
    corte_medio <- (mean(theta1) + mean(theta2)) / 2
    mal_clasificados1 <- sum(theta1 > corte_medio) / length(theta1)
    mal_clasificados2 <- sum(theta2 < corte_medio) / length(theta2)
    
    traslape <- rbind(traslape,
      data.frame(
        Transicion = paste(cat1, "‚Üí", cat2),
        traslape_Pct = round((mal_clasificados1 + mal_clasificados2) / 2 * 100, 1),
        Theta_Gap = round(mean(theta2) - mean(theta1), 3),
        Info_en_corte = round(info_transiciones_2pl[i], 2)
      )
    )
  }
  
  print(traslape)
  
  
  # Verificar si los puntos de corte est√°n en zonas de baja informaci√≥n
  info_baja <- any(info_transiciones_2pl < 2)
  if(info_baja) {
    cat("‚ö† Algunos puntos de corte est√°n en zonas de baja informaci√≥n (<2).\n")
    cat("  Considere ajustar los puntos de corte o a√±adir m√°s √≠tems en esas zonas.\n")
  } else {
    cat("‚úì Los puntos de corte est√°n en zonas con informaci√≥n adecuada (‚â•2).\n")
  }
  
  return(list(
    theta_por_categoria = theta_por_categoria,
    info_transiciones = df_transiciones,
    traslape = traslape,
    info_por_score = info_por_score,
    graficos = list(dist_theta = p1, info_score = p2, info_continuo = p3)
  ))
}

# Aplicar el an√°lisis
cat("\n=== AN√ÅLISIS DE PARTICIONES TRADICIONALES EMSA ===\n")
cat("Particiones tradicionales: 0 | 1-3 | 4-7 | 8-12\n")
cat("(Seguridad | Inseg. Leve | Inseg. Moderada | Inseg. Severa)\n")

analisis_particiones <- comparar_puntos_corte_tradicionales(m, m2, D[,2:13])
```

### Interpretaci√≥n de las particiones tradicionales EMSA:

**Evaluaci√≥n desde la perspectiva de informaci√≥n:**

1. **Informaci√≥n en puntos de corte**: ¬øLos cortes est√°n en zonas de alta o baja precisi√≥n?
2. **traslape entre categor√≠as**: ¬øQu√© tan bien separadas est√°n las categor√≠as en t√©rminos de theta?
3. **Consistencia entre modelos**: ¬øLas particiones funcionan igual para Rasch y 2PL?


## An√°lisis 4: Confiabilidad Condicional del Test

La confiabilidad no es constante a lo largo de toda la escala. Es importante entender d√≥nde el test es m√°s confiable.

```{r message=FALSE, warning=FALSE}
# An√°lisis de confiabilidad condicional
confiabilidad_condicional <- function(modelo) {
  # Calcular informaci√≥n y confiabilidad a lo largo del continuo
  theta_continuo <- seq(-3, 3, by = 0.05)
  info_continuo <- testinfo(modelo, matrix(theta_continuo))
  se_continuo <- 1/sqrt(info_continuo)
  
  # Confiabilidad marginal aproximada
  # Rel = 1 - (SE^2 / Var(theta))
  var_theta <- 1  # Asumiendo distribuci√≥n est√°ndar
  confiab_continuo <- 1 - (se_continuo^2 / var_theta)
  confiab_continuo[confiab_continuo < 0] <- 0
  confiab_continuo[confiab_continuo > 1] <- 1
  
  df_continuo <- data.frame(
    theta = theta_continuo,
    confiabilidad = confiab_continuo,
    se = se_continuo,
    informacion = info_continuo
  )
  
  # Identificar zonas de alta confiabilidad
  zonas_alta_conf <- df_continuo[df_continuo$confiabilidad > 0.8, ]
  rango_optimo <- c(min(zonas_alta_conf$theta), max(zonas_alta_conf$theta))
  
  p <- ggplot(df_continuo, aes(x = theta)) +
    geom_line(aes(y = confiabilidad), color = "blue", size = 1.2) +
    geom_ribbon(aes(ymin = 0, ymax = confiabilidad), 
                fill = "lightblue", alpha = 0.3) +
    geom_hline(yintercept = 0.7, linetype = "dashed", color = "orange", alpha = 0.7) +
    geom_hline(yintercept = 0.8, linetype = "dashed", color = "darkgreen", alpha = 0.7) +
    geom_hline(yintercept = 0.9, linetype = "dashed", color = "darkblue", alpha = 0.7) +
    
    # Zona √≥ptima
    annotate("rect", xmin = rango_optimo[1], xmax = rango_optimo[2],
             ymin = 0, ymax = 1, fill = "green", alpha = 0.1) +
    
    # Etiquetas
    annotate("text", x = 2.5, y = 0.72, label = "Œ± = 0.70", color = "orange", size = 3) +
    annotate("text", x = 2.5, y = 0.82, label = "Œ± = 0.80", color = "darkgreen", size = 3) +
    annotate("text", x = 2.5, y = 0.92, label = "Œ± = 0.90", color = "darkblue", size = 3) +
    
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.1)) +
    labs(title = "Confiabilidad Condicional del Test EMSA",
         subtitle = paste("Zona √≥ptima (Œ± > 0.8): Œ∏ entre", round(rango_optimo[1], 2), 
                         "y", round(rango_optimo[2], 2)),
         x = expression(theta ~ "(Inseguridad Alimentaria)"),
         y = "Confiabilidad") +
    theme_minimal()
  
  # Tabla resumen por rangos
  rangos <- list(
    "Muy Bajo [-3, -2)" = c(-3, -2),
    "Bajo [-2, -1)" = c(-2, -1),
    "Medio [-1, 1]" = c(-1, 1),
    "Alto (1, 2]" = c(1, 2),
    "Muy Alto (2, 3]" = c(2, 3)
  )
  
  resumen_rangos <- data.frame()
  for(nombre in names(rangos)) {
    rango <- rangos[[nombre]]
    idx <- which(theta_continuo >= rango[1] & theta_continuo <= rango[2])
    resumen_rangos <- rbind(resumen_rangos,
                            data.frame(
                              Rango = nombre,
                              Confiabilidad_Media = round(mean(confiab_continuo[idx]), 3),
                              SE_Medio = round(mean(se_continuo[idx]), 3),
                              Informacion_Media = round(mean(info_continuo[idx]), 2)
                            ))
  }
  
  print(p)
  
  return(list(
    grafico = p,
    resumen = resumen_rangos,
    rango_optimo = round(rango_optimo, 2)
  ))
}

cat("\n=== AN√ÅLISIS DE CONFIABILIDAD CONDICIONAL ===\n")
confiab_analisis <- confiabilidad_condicional(m2)

cat("\nResumen de confiabilidad por rangos de theta:\n")
print(confiab_analisis$resumen)

cat("\nRango √≥ptimo de medici√≥n (confiabilidad > 0.8):\n")
cat("Œ∏ entre", confiab_analisis$rango_optimo[1], "y", confiab_analisis$rango_optimo[2], "\n")

confiab_1pl <- confiabilidad_condicional(m)  # modelo 2PL
confiab_2pl <- confiabilidad_condicional(m2)
library(dplyr)
df1 <- confiab_1pl$grafico$data %>% mutate(Modelo = "Rasch")
df2 <- confiab_2pl$grafico$data %>% mutate(Modelo = "2PL")



ggplot(bind_rows(df1, df2), aes(x = theta, y = confiabilidad, color = Modelo)) +
  geom_line(size = 1.2) +
  scale_color_manual(values = c("blue", "red")) +
  labs(title = "Comparaci√≥n de Confiabilidad Condicional entre Modelos",
       x = expression(theta), y = "Confiabilidad") +
  theme_minimal()

```

### Interpretaci√≥n de la confiabilidad condicional:
- **Confiabilidad variable**: El test no es igualmente confiable en todo el rango
- **Zona √≥ptima**: La EMSA es m√°s confiable en niveles medios de inseguridad alimentaria
- **Implicaciones**: Para hogares en extremos, considerar instrumentos adicionales o m√°s √≠tems

## An√°lisis 5: Simulaci√≥n Monte Carlo - Validaci√≥n del Modelo

Para entender mejor la relaci√≥n entre los scores observados y theta, realizamos una simulaci√≥n donde conocemos los valores "verdaderos". Es decir, 

‚ÄúSi el modelo fuera cierto, ¬øqu√© tan bien podr√≠amos estimar los niveles verdaderos de inseguridad alimentaria de las personas?‚Äù

Esto imita c√≥mo responder√≠an esas personas si el modelo fuera ‚Äúla verdad‚Äù.

La funci√≥n adem√°s calcula c√≥mo var√≠a el error o RMSE seg√∫n el score total observado (n√∫mero de √≠tems afirmativos).

- Si el RMSE es bajo (cercano a 0), el modelo estima bien a esas personas.

- Si es alto en los extremos (scores muy bajos o muy altos), indica menor precisi√≥n en esos rangos, lo cual es t√≠pico de los tests IRT.

```{r message=FALSE, warning=FALSE}
simular_relacion_score_theta <- function(modelo, n_sim = 1000) {
  set.seed(2024)
  
  # 1. Extraer par√°metros
  coef_list <- mirt::coef(modelo, simplify = TRUE)
  
  if ("items" %in% names(coef_list)) {
    # --- Caso: coeficientes consolidados en matriz (tu caso) ---
    item_mat <- coef_list$items
    a_pars <- item_mat[, "a1"]
    d_pars <- item_mat[, "d"]
    item_names <- rownames(item_mat)
  } else {
    # --- Caso: coeficientes por √≠tem en lista ---
    item_pars <- coef_list[!names(coef_list) %in% "GroupPars"]
    a_pars <- sapply(item_pars, function(x) if ("a1" %in% names(x)) x[["a1"]] else 1)
    d_pars <- sapply(item_pars, function(x) if ("d" %in% names(x)) x[["d"]] else 0)
    item_names <- names(item_pars)
  }
  
  n_items <- length(a_pars)
  itemtype <- mirt::extract.mirt(modelo, "itemtype")
  if (length(itemtype) != n_items) itemtype <- rep("2PL", n_items)
  
  # --- Diagn√≥stico de par√°metros ---
  cat("\nChequeo de par√°metros:\n")
  cat("√çtems:", n_items, "\n")
  cat("Primeros a:", round(head(a_pars), 3), "\n")
  cat("Primeros d:", round(head(d_pars), 3), "\n")
  cat("Itemtype:", unique(itemtype), "\n\n")
  
  # 2. Generar thetas verdaderos
  thetas_verdaderos <- rnorm(n_sim, 0, 1)
  
  # 3. Convertir a matriz con nombres correctos
  a_mat <- matrix(a_pars, nrow = n_items, ncol = 1)
  rownames(a_mat) <- item_names
  d_vec <- as.numeric(d_pars)
  names(d_vec) <- item_names
  
  # 4. Simular respuestas
  datos_sim <- mirt::simdata(
    a = a_mat,
    d = d_vec,
    itemtype = itemtype,
    Theta = matrix(thetas_verdaderos, ncol = 1)
  )
  
  # 5. Calcular scores y estimar thetas
  scores_obs <- rowSums(datos_sim)
  theta_est_matrix <- mirt::fscores(modelo, response.pattern = datos_sim, 
                                    method = "EAP", full.scores = TRUE)
  thetas_estimados <- as.vector(theta_est_matrix[, 1])
  
  # 6. Consolidar resultados
  df_sim <- data.frame(
    theta_verdadero = thetas_verdaderos,
    theta_estimado = thetas_estimados,
    score_observado = scores_obs,
    error = thetas_estimados - thetas_verdaderos,
    error_abs = abs(thetas_estimados - thetas_verdaderos)
  )
  
  cor_recuperacion <- cor(df_sim$theta_verdadero, df_sim$theta_estimado)
  
  # 7. Estad√≠sticas
  cat("\n=== ESTAD√çSTICAS DE RECUPERACI√ìN ===\n")
  cat("Correlaci√≥n:", round(cor_recuperacion, 3), "\n")
  cat("RMSE:", round(sqrt(mean(df_sim$error^2)), 3), "\n")
  cat("Sesgo medio:", round(mean(df_sim$error), 3), "\n")
  
  # 8. Gr√°ficos
  p1 <- ggplot(df_sim, aes(x = theta_verdadero, y = theta_estimado)) +
    geom_point(alpha = 0.3, color = "blue") +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
    annotate("text", x = -2, y = 2.5, 
             label = paste("r =", round(cor_recuperacion, 3)), 
             size = 4, color = "darkblue") +
    labs(title = "Recuperaci√≥n de Par√°metros: Theta Verdadero vs Estimado",
         x = expression(theta ~ "verdadero"),
         y = expression(theta ~ "estimado")) +
    theme_minimal() +
    coord_fixed()
  
  p2 <- ggplot(df_sim, aes(x = score_observado, y = error)) +
    geom_boxplot(aes(group = score_observado), fill = "lightyellow", alpha = 0.7) +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    geom_smooth(method = "loess", color = "blue", se = TRUE) +
    labs(title = "Error de Estimaci√≥n \n por Score Observado",
         x = "Score Observado", y = "Error de Estimaci√≥n") +
    theme_minimal() +
    scale_x_continuous(breaks = 0:12)
  
  gridExtra::grid.arrange(p1, p2, ncol = 2)
  
  # 9. RMSE por score
  rmse_por_score <- aggregate(error_abs ~ score_observado, df_sim, 
                              function(x) c(rmse = round(sqrt(mean(x^2)), 3),
                                            n = length(x)))
  rmse_por_score <- do.call(data.frame, rmse_por_score)
  colnames(rmse_por_score) <- c("Score", "RMSE", "N")
  
  return(list(
    simulacion = df_sim, 
    rmse_score = rmse_por_score,
    correlacion = cor_recuperacion
  ))
}


# Ejecutar simulaci√≥n
cat("\n=== SIMULACI√ìN MONTE CARLO ===\n")
sim_resultados <- simular_relacion_score_theta(m2, n_sim = 2000)

cat("\nRMSE por score observado:\n")
print(sim_resultados$rmse_score)
```

### Interpretaci√≥n de la simulaci√≥n:
- **Alta recuperaci√≥n**: La correlaci√≥n entre theta verdadero y estimado es muy alta
- **Sesgo m√≠nimo**: El modelo recupera los par√°metros sin sesgo sistem√°tico
- **Error variable**: El error de estimaci√≥n var√≠a seg√∫n el nivel del score


Hacemos la misma simulaci√≥n para el de un par√°metro


```{r}
simular_relacion_score_theta_rasch <- function(modelo, n_sim = 1000) {
  set.seed(2024)
  
  coef_list <- mirt::coef(modelo, simplify = TRUE)
  
  if ("items" %in% names(coef_list)) {
    item_mat <- coef_list$items
    a_pars <- item_mat[, "a1"]
    d_pars <- item_mat[, "d"]
    item_names <- rownames(item_mat)
  } else {
    item_pars <- coef_list[!names(coef_list) %in% "GroupPars"]
    a_pars <- sapply(item_pars, function(x) if ("a1" %in% names(x)) x[["a1"]] else 1)
    d_pars <- sapply(item_pars, function(x) if ("d" %in% names(x)) x[["d"]] else 0)
    item_names <- names(item_pars)
  }
  
  n_items <- length(a_pars)
  itemtype <- rep("dich", n_items)  # üîπ <- cambio clave
  
  cat("\nChequeo de par√°metros:\n")
  cat("√çtems:", n_items, "\n")
  cat("Primeros a:", round(head(a_pars), 3), "\n")
  cat("Primeros d:", round(head(d_pars), 3), "\n")
  cat("Itemtype:", unique(itemtype), "\n\n")
  
  thetas_verdaderos <- rnorm(n_sim, 0, 1)
  
  a_mat <- matrix(a_pars, nrow = n_items, ncol = 1)
  rownames(a_mat) <- item_names
  d_vec <- as.numeric(d_pars)
  names(d_vec) <- item_names
  
  datos_sim <- mirt::simdata(
    a = a_mat,
    d = d_vec,
    itemtype = itemtype,
    Theta = matrix(thetas_verdaderos, ncol = 1)
  )
  
  scores_obs <- rowSums(datos_sim)
  theta_est_matrix <- mirt::fscores(modelo, response.pattern = datos_sim, method = "EAP", full.scores = TRUE)
  thetas_estimados <- as.vector(theta_est_matrix[, 1])
  
  df_sim <- data.frame(
    theta_verdadero = thetas_verdaderos,
    theta_estimado = thetas_estimados,
    score_observado = scores_obs,
    error = thetas_estimados - thetas_verdaderos,
    error_abs = abs(thetas_estimados - thetas_verdaderos)
  )
  
  cor_recuperacion <- cor(df_sim$theta_verdadero, df_sim$theta_estimado)
  
  cat("\n=== ESTAD√çSTICAS DE RECUPERACI√ìN ===\n")
  cat("Correlaci√≥n:", round(cor_recuperacion, 3), "\n")
  cat("RMSE:", round(sqrt(mean(df_sim$error^2)), 3), "\n")
  cat("Sesgo medio:", round(mean(df_sim$error), 3), "\n")
  
  rmse_por_score <- aggregate(error_abs ~ score_observado, df_sim, 
                              function(x) c(rmse = round(sqrt(mean(x^2)), 3),
                                            n = length(x)))
  rmse_por_score <- do.call(data.frame, rmse_por_score)
  colnames(rmse_por_score) <- c("Score", "RMSE", "N")
  
  return(list(
    simulacion = df_sim,
    rmse_score = rmse_por_score,
    correlacion = cor_recuperacion
  ))
}


# Ejecutar simulaci√≥n
sim_resultados_rasch <- simular_relacion_score_theta_rasch(m, n_sim = 2000)
print(sim_resultados_rasch$rmse_score)

```

